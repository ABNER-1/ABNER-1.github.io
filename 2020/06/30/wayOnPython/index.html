<!DOCTYPE html>
<html lang="en">
  <!-- Head tag -->
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Title -->
  
  <title>python 踩坑日记 - Abner&#39;s Blog</title>

  <!--Favicon-->
  <link rel="icon" href="favicon/favicon.ico">

  <!--Description-->
  
      <meta name="description" content="A space where I put my study\read\work data">
  

  <!--Author-->
  
      <meta name="author" content="Abner">
  

  <!-- Pure CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
  <link href="https://fonts.googleapis.com/css?family=Crimson+Text|Open+Sans:300,800" rel="stylesheet">

  <!-- Custom CSS -->
  
<link rel="stylesheet" href="/css/styles.css">


  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->

  <!-- Google Analytics -->
  

<meta name="generator" content="Hexo 4.2.1"></head>


  <body>
  	<div class="container-fluid navbar-container m-sm-5">
      <!-- Header -->
      <nav class="navbar navbar-toggleable-sm navbar-light px-1 py-3 my-3 mb-sm-5">
  <a class="navbar-brand ml-2" href="/">Abner's Blog</a>
  <button class="navbar-toggler navbar-toggler-right py-2" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse text-center" id="navbarCollapse">
    <ul class="navbar-nav ml-auto my-auto">
      
        <li class="nav-item">
          <a class="nav-link" href="/about">About</a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="/contact">Contact</a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://gitee.com/abner1997" target="_blank" rel="noopener">Gitee</a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/ABNER-1" target="_blank" rel="noopener">Github</a>
        </li>
      
    </ul>
    <hr class="hidden-md-up" />
  </div>
</nav>


  		<div class="row">
  			<div class="col-12 mb-4">
  <img class="img-fluid project-img" src="/images/unsplash.jpg" alt="python 踩坑日记">
</div>
<div class="col-lg-4 col-12 pt-3 px-4 pr-lg-5">
  <h1>python 踩坑日记</h1>
</div>
<div class="col-lg-8 col-12 pt-lg-3 mb-4 pl-lg-5 px-lg-0 px-4 portfolio-content">
  <p>这段时间一直在写 python， 学了不少东西，今天填填坑，记录一下。</p>
<a id="more"></a>

<h3 id="python-装饰器"><a href="#python-装饰器" class="headerlink" title="python 装饰器"></a>python 装饰器</h3><p>之前了解过 python 的装饰器， 原理简单说来就是在被装饰的方法前后添加一些自定义的逻辑。<a href="https://www.geeksforgeeks.org/python-functools-wraps-function/" target="_blank" rel="noopener">参考文档</a></p>
<p>一个简单的装饰器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_decorator</span><span class="params">(func)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span> </span><br><span class="line">        <span class="string">"""A wrapper function"""</span></span><br><span class="line">        <span class="comment"># do something here, or do some changes on params</span></span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        <span class="comment"># do something here</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_function</span><span class="params">()</span>:</span> </span><br><span class="line">    <span class="string">"""This is docstring for first function"""</span></span><br><span class="line">    print(<span class="string">"first function"</span>)</span><br></pre></td></tr></table></figure>

<p>但是这样的装饰器是不完美的，如果有 log 打印或者其他一些关于方法的需求，如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(first_function.__name__) </span><br><span class="line">print(first_function.__doc__)</span><br><span class="line"><span class="comment"># result blow</span></span><br><span class="line"><span class="comment"># wrapper</span></span><br><span class="line"><span class="comment"># A wrapper function</span></span><br></pre></td></tr></table></figure>

<p>此时的打印的是装饰器的属性，这样可以预想是很不利于实际使用过程中的调试或者日志记录的。</p>
<p>我们手动赋值可以解决这个麻烦：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_decorator</span><span class="params">(func)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span> </span><br><span class="line">        <span class="string">"""A wrapper function"""</span></span><br><span class="line">        <span class="comment"># do something here, or do some changes on params</span></span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        wrapper.__name__ = func.__name__ </span><br><span class="line">        wrapper.__doc__ = func.__doc__ </span><br><span class="line">        <span class="comment"># do something here</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>或者使用 <code>@wraps</code> 装饰器也同样可以做到</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_decorator</span><span class="params">(func)</span>:</span> </span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span> </span><br><span class="line">        <span class="string">"""A wrapper function"""</span></span><br><span class="line">        <span class="comment"># do something here, or do some changes on params</span></span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        <span class="comment"># do something here</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>本质上来说， <code>@wraps(func)</code> 的作用相当于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wrapper.__name__ = func.__name__</span><br><span class="line">wrapper.__doc__ = func.__doc__</span><br></pre></td></tr></table></figure>

<h3 id="python-类函数调用"><a href="#python-类函数调用" class="headerlink" title="python 类函数调用"></a>python 类函数调用</h3><p>众所周知， python 不同于 C/C+， 其是一个解释型的纯动态语言。所以很多设计模式，其实和编译型的语言有很大不同。</p>
<p>比如，今天在调试 <code>docker containers</code> 库的时候，一个类方法调用了一个私有方法（_开头）， 在这个类中并没有找到这个方法，本能地去这个类的父类中找。 但其父类是 object，这就奇了怪了，难不成这个方法是自带的？ 这显然不可能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContainerApiMixin</span><span class="params">(object)</span>:</span></span><br><span class="line">    ……</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_container_from_config</span><span class="params">(self, config, name=None)</span>:</span></span><br><span class="line">        u = self._url(<span class="string">"/containers/create"</span>)</span><br><span class="line">        params = &#123;</span><br><span class="line">            <span class="string">'name'</span>: name</span><br><span class="line">        &#125;</span><br><span class="line">        res = self._post_json(u, data=config, params=params)</span><br><span class="line">        <span class="keyword">return</span> self._result(res, <span class="literal">True</span>)</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure>

<p>第二反应是某个装饰器将其他类的方法 import 进来了，但查看 import， 依然没有。在实际调试的过程中，逐步 debug 定位到了实际的函数。查看原因发现，那个函数所在的类继承了上面那个类，也就是父类调用了子类的一个方法，但父类并没有实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIClient</span><span class="params">(</span></span></span><br><span class="line"><span class="class"><span class="params">        requests.Session,</span></span></span><br><span class="line"><span class="class"><span class="params">        BuildApiMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">        ConfigApiMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">        ContainerApiMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">        DaemonApiMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">        ExecApiMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">        ImageApiMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">        NetworkApiMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">        PluginApiMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">        SecretApiMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">        ServiceApiMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">        SwarmApiMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">        VolumeApiMixin)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>而在 C++ 程序当中是编译不过的。。至少得定义一个方法，让子类去重写呀。<br>不过联想到 python 语言的特性，其实也并没有错，但对于代码的可读性来说真的有点难受，只有调试一下才可以读懂里面的逻辑。</p>

</div>


      </div>
      
  	</div>

    <!-- After footer scripts -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha384-A7FZj7v+d/sdmMqp/nOQwliLvUsJfDHW+k9Omg/a/EheAdgtzNs3hpfag6Ed950n" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>

  </body>
</html>
